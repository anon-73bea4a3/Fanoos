

import config;
_LOCALDEBUGFLAG = config.debugFlags.get_v_print_ForThisFile(__file__);
    
import numpy as np;
import pickle;

def getTrainedModelWeightAndBiases(nameOfFileToLoad):
    fh = open(nameOfFileToLoad, "rb");
    A = pickle.load(fh);
    fh.close();
    return A;

pathToFile ="./networkLayers.pickle";
tempDict = getTrainedModelWeightAndBiases(pathToFile);

def getParam(name):
    return np.array(tempDict["model/pi" + name + ":0"], dtype=float);

def  getParam_valueFunct(name):
    return np.array(tempDict["model/vf" + name + ":0"], dtype=float);


modelToSave = {"weights" : [0,0,0], "biases" : [0,0,0]};
modelToSave["weights"][0] = getParam('_fc0/w');
modelToSave["weights"][1] = getParam('_fc1/w');
modelToSave["weights"][2] = getParam('/w');
modelToSave["biases"][0] = getParam('_fc0/b').flatten();
modelToSave["biases"][1] = getParam('_fc1/b').flatten();
modelToSave["biases"][2] = getParam('/b').flatten();


modelToSave["v_weights"] =  [0,0,0];
modelToSave["v_biases"] = [0,0,0];
modelToSave["v_weights"][0] = getParam_valueFunct('_fc0/w');
modelToSave["v_weights"][1] = getParam_valueFunct('_fc1/w');
modelToSave["v_weights"][2] = getParam_valueFunct('/w');
modelToSave["v_biases"][0] = getParam_valueFunct('_fc0/b').flatten();
modelToSave["v_biases"][1] = getParam_valueFunct('_fc1/b').flatten();
modelToSave["v_biases"][2] = getParam_valueFunct('/b').flatten();


codeForClippingFunction = """
def properlyTransformAction(thisAction):
    requires(isinstance(thisAction, np.ndarray));
    requires(len(thisAction.shape) == 1);
    requires(thisAction.shape[0] == 2);
    # ssh-rsa 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 abc@defg
    lb = np.array([ -1 , -float("inf")]);
    ub = np.array([  1,   float("inf")]);
    scaled_action = np.clip(thisAction, lb, ub);
    ensures(isinstance(scaled_action, np.ndarray));
    ensures(len(scaled_action.shape) == 1);
    ensures(scaled_action.shape[0] == 2);
    ensures(np.all(lb <= scaled_action));
    ensures(np.all(scaled_action <= ub));
    return scaled_action;
""";



codeForPushingValuesThroughNetwork = """
def pushBoxThrough(self, thisBoxInitial):
    requires(getDimensionOfBox(thisBoxInitial) == 7);


    def normalize_obs(obs: np.ndarray) -> np.ndarray:
        '''
        See: https://stable-baselines.readthedocs.io/en/master/_modules/stable_baselines/common/vec_env/vec_normalize.html#VecNormalize
        Normalize observations using this VecNormalize's observations statistics.
        Calling this method does not update statistics.
        '''
        obs_rms_mean = np.array([float.fromhex(x) for x in \
            ['-0x1.b77efabdeab5cp-2', '-0x1.b59fd13b14562p-4', '-0x1.c4bcd6925511fp-2', \
             '0x1.fc28fe890e974p-1', '-0x1.b05cdd0a57ae1p-6', '-0x1.3f597d80568ffp-4', \
             '0x1.f8352e45950f2p-1', '0x1.caea4c56e0357p-6', '0x1.7e22dba621535p-3']
        ]);
        # ssh-rsa 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 abc@defg
        obs_rms_var = np.array([float.fromhex(x) for x in \
           ['0x1.544b06860465cp-3', '0x1.ed35aa7e5a76bp-3', '0x1.4cf8dfe3c1d18p-3', \
            '0x1.8d9cec886a9a1p-11', '0x1.b9fd4ce62ce65p-7', '0x1.8ddbf1a6a94adp-2', \
            '0x1.a2e34153dfe07p-8', '0x1.79556f17af25ep-6', '0x1.00a9a20606534p+0']
        ]);
        epsilon = float.fromhex('0x1.5798ee2308c3ap-27');
        clip_obs = float.fromhex('0x1.4000000000000p+3');

        obs = np.clip((obs - obs_rms_mean) / np.sqrt(obs_rms_var + epsilon),
                      -clip_obs,
                      clip_obs)
        return obs;
    
    
    def normalize_obs_box(thisBox):
        requires(isProperBox(thisBox));
        A = normalize_obs(thisBox[:,0]);
        B = normalize_obs(thisBox[:,1]);
        boxToReturn = getBox(A, B);
        ensures(isProperBox(boxToReturn));
        return boxToReturn;


    def helper_pushBoxThrough_noClipping(weights, biases, thisBox):
        A1 = computeBoxOutputForLayer( thisBox,  weights[0], biases[0], activationFunctionName ="tanh"   );
        B2 = computeBoxOutputForLayer( A1,  weights[1], biases[1], activationFunctionName ="tanh"   );
        C3 = computeBoxOutputForLayer( B2,  weights[2], biases[2], activationFunctionName ="linear"   );
        return C3;

    def maximumCos(bound): # bound = np.array([start, end])
        piPortions = tuple(np.floor(bound / np.pi));
        assert(piPortions[1] >= piPortions[0]);
        if(piPortions[0] == piPortions[1]):
            return np.max(np.cos(bound));
        if(piPortions[0] % 2 == 0):
            assert(piPortions[1] - piPortions[0] >= 1);
            if(piPortions[1] == piPortions[0] + 1):
                return np.max(np.cos(bound));
            else:
                assert(piPortions[1] >= 2 + piPortions[0]);
                return 1;
        assert(piPortions[0] % 2 == 1);
        assert(piPortions[1] > piPortions[0]);
        return 1;
    
    
    def minimumCos(bound): # bound = np.array([start, end])
        piPortions = tuple(np.floor(bound / np.pi));
        assert(piPortions[1] >= piPortions[0]);
        if(piPortions[0] == piPortions[1]):
            return np.min(np.cos(bound));
        if(piPortions[0] % 2 == 1):
            if(piPortions[1] == piPortions[0] + 1):
                return np.min(np.cos(bound));
            else:
                assert(piPortions[1] >= 2 + piPortions[0]);
                return -1;
        assert(piPortions[0] % 2 == 0);
        assert(piPortions[1] > piPortions[0]);
        return -1;
    
    def pushBoundThroughCos(bound):
        lb = minimumCos(bound);
        ub = maximumCos(bound);
        return np.array([lb, ub]);
    
    def pushBoundThroughSin(bound):
        return pushBoundThroughCos(bound - (np.pi / 2));
    
    weights = self.thisModel["weights"];
    biases = self.thisModel["biases"];

    v_weights = self.thisModel["v_weights"];
    v_biases = self.thisModel["v_biases"];

    # Below, we have thisBoxInitial[2,:] + thisBoxInitial[1,:] becuase:
    #     thisBoxInitial[2,:] is the DELTA between the base of the robot and
    #         x-value for the CENTER of pole2 (the code in rl-baselines-zoo
    #         refers to it as the end of pole2, but the bullet simulator actually
    #         get the position from the center of the pole - this behaviour
    #         is actually explicitly considered in the code defining the inverted
    #         doulbe-pendulum environment - see gym_pendulum_envs.py).
    #    thisBoxInitial[1,:] is the x-value for the base of the robot
    #
    #    thus, there sum gives the x-value of the pole2 "end" in respect to the
    #    global reference frame, which is what the policy has been trained to expect.

    thisBox = np.array([\
        thisBoxInitial[0,:], \
        thisBoxInitial[1,:], \
        thisBoxInitial[2,:] + thisBoxInitial[0,:], \
        pushBoundThroughCos(thisBoxInitial[3,:]), \
        pushBoundThroughSin(thisBoxInitial[3,:]), \
        thisBoxInitial[4,:], \
        pushBoundThroughCos(thisBoxInitial[5,:]), \
        pushBoundThroughSin(thisBoxInitial[5,:]), \
        thisBoxInitial[6,:] \
        ]);

    thisBox = normalize_obs_box(thisBox);

    unclippedAction = helper_pushBoxThrough_noClipping(weights, biases, thisBox)
    unclippedValue = helper_pushBoxThrough_noClipping(v_weights, v_biases, thisBox)
    clippedAndTransformedC3 = self.clipAndScaleResultBox(getJointBox([unclippedAction, unclippedValue]));
    return clippedAndTransformedC3;
""";""" ssh-rsa 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 abc@defg"""

modelToSave["clippingFunctionCode"] = codeForClippingFunction;
modelToSave["functionToPushBoxThroughModel"] = codeForPushingValuesThroughNetwork;



nameOfFileToLoad = "./networkLayers_putIntoProperFormat.pickle";
fh = open(nameOfFileToLoad, "wb");
pickle.dump(modelToSave, fh);
fh.close();


